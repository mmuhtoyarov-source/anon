from __future__ import annotations

import asyncio
import logging

from aiogram import Router
from aiogram.filters import CommandStart
from aiogram.types import Message

from keyboards import (
    BANNED_KB,
    BROWSE_TOPICS_KB,
    BTN_BACK,
    BTN_BROWSE_TOPICS,
    BTN_CANCEL,
    BTN_CANCEL_SEARCH,
    BTN_CONFIRM,
    BTN_CREATE_TOPIC,
    BTN_END_DIALOG,
    BTN_FIND,
    BTN_NEXT_TOPIC,
    BTN_REPORT,
    BTN_START_DIALOG,
    CONFIRM_TOPIC_KB,
    CREATE_TOPIC_KB,
    DIALOG_KB,
    MAIN_MENU_KB,
    SEARCHING_KB,
)
from services.dialogs import DialogService
from services.matchmaking import MatchmakingService
from services.safe_sender import safe_copy_to, safe_reply, safe_send_message
from services.topics import TopicService
from states import UserState
from storage.postgres_store import PostgresStorage
from storage.redis_store import RedisStorage

logger = logging.getLogger(__name__)
router = Router()


@router.message(CommandStart())
async def on_start(message: Message, redis: RedisStorage, pg: PostgresStorage) -> None:
    logger.info(f"on_start: user={message.from_user.id}, text={message.text}")
    await pg.upsert_user(message.from_user.id)
    if await redis.has_ttl_flag("ban", message.from_user.id):
        await redis.set_state(message.from_user.id, UserState.BANNED)
        await safe_reply(message, " Р’С‹ РІСЂРµРјРµРЅРЅРѕ Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅС‹", reply_markup=BANNED_KB)
        return
    await redis.set_state(message.from_user.id, UserState.IDLE)
    await safe_reply(message, "Р’С‹Р±РµСЂРёС‚Рµ РґРµР№СЃС‚РІРёРµ", reply_markup=MAIN_MENU_KB)


@router.message()
async def on_message(
    message: Message,
    redis: RedisStorage,
    matchmaking: MatchmakingService,
    dialogs: DialogService,
    topics: TopicService,
) -> None:
    logger.info(f"on_message: user={message.from_user.id}, state={await redis.get_state(message.from_user.id)}, text={message.text}")
    user_id = message.from_user.id
    message: Message,
    redis: RedisStorage,
    matchmaking: MatchmakingService,
    dialogs: DialogService,
    topics: TopicService,
) -> None:
    user_id = message.from_user.id
    if await redis.has_ttl_flag("ban", user_id):
        await redis.set_state(user_id, UserState.BANNED)
        await safe_reply(message, " Р’С‹ РІСЂРµРјРµРЅРЅРѕ Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅС‹", reply_markup=BANNED_KB)
        return

    state = await redis.get_state(user_id)
    text = message.text or ""
    if state == UserState.IDLE:
        await handle_idle(message, text, redis, matchmaking)
    elif state == UserState.SEARCHING:
        await handle_searching(message, text, matchmaking)
    elif state == UserState.CREATE_TOPIC:
        await handle_create_topic(message, text, redis)
    elif state == UserState.CONFIRM_TOPIC:
        await handle_confirm_topic(message, text, redis, topics)
    elif state == UserState.BROWSING_TOPICS:
        await handle_browsing(message, text, redis, matchmaking, dialogs)
    elif state == UserState.IN_DIALOG:
        await handle_dialog(message, text, redis, dialogs)
    else:
        await safe_reply(message, " Р’С‹ РІСЂРµРјРµРЅРЅРѕ Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅС‹", reply_markup=BANNED_KB)


async def handle_idle(message: Message, text: str, redis: RedisStorage, matchmaking: MatchmakingService) -> None:
    user_id = message.from_user.id
    if text == BTN_FIND:
        await matchmaking.begin_search(user_id)
        await safe_reply(message, "РС‰РµРј СЃРѕР±РµСЃРµРґРЅРёРєР°...", reply_markup=SEARCHING_KB)
        asyncio.create_task(search_with_timeout(message, matchmaking, redis, 20))
        return
    if text == BTN_CREATE_TOPIC:
        await redis.set_state(user_id, UserState.CREATE_TOPIC)
        await safe_reply(message, "Р’РІРµРґРёС‚Рµ С‚РµРєСЃС‚ С‚РµРјС‹", reply_markup=CREATE_TOPIC_KB)
        return
    if text == BTN_BROWSE_TOPICS:
        await enter_browse_topics(message, redis)
        return
    await safe_reply(message, "Р’С‹Р±РµСЂРёС‚Рµ РґРµР№СЃС‚РІРёРµ", reply_markup=MAIN_MENU_KB)




async def search_with_timeout(
    message: Message,
    matchmaking: MatchmakingService,
    redis: RedisStorage,
    timeout_seconds: int,
) -> None:
    user_id = message.from_user.id
    for _ in range(timeout_seconds):
        state = await redis.get_state(user_id)
        if state != UserState.SEARCHING:
            return
        matched, _dialog_id, partner = await matchmaking.try_match(user_id)
        if matched:
            await safe_send_message(message.bot, user_id, "РЎРѕР±РµСЃРµРґРЅРёРє РЅР°Р№РґРµРЅ!", reply_markup=DIALOG_KB)
            await safe_send_message(message.bot, partner, "РЎРѕР±РµСЃРµРґРЅРёРє РЅР°Р№РґРµРЅ!", reply_markup=DIALOG_KB)
            return
        await asyncio.sleep(1)
    await matchmaking.cancel_search(user_id)
    await safe_send_message(message.bot, user_id, "РџРѕРёСЃРє Р·Р°РІРµСЂС€РµРЅ РїРѕ С‚Р°Р№РјР°СѓС‚Сѓ", reply_markup=MAIN_MENU_KB)

async def handle_searching(message: Message, text: str, matchmaking: MatchmakingService) -> None:
    user_id = message.from_user.id
    if text == BTN_CANCEL_SEARCH:
        await matchmaking.cancel_search(user_id)
        await safe_reply(message, "РџРѕРёСЃРє РѕСЃС‚Р°РЅРѕРІР»РµРЅ", reply_markup=MAIN_MENU_KB)
        return
    matched, _dialog_id, partner = await matchmaking.try_match(user_id)
    if matched:
        await safe_reply(message, "РЎРѕР±РµСЃРµРґРЅРёРє РЅР°Р№РґРµРЅ!", reply_markup=DIALOG_KB)
        await safe_send_message(message.bot, partner, "РЎРѕР±РµСЃРµРґРЅРёРє РЅР°Р№РґРµРЅ!", reply_markup=DIALOG_KB)
        return
    await asyncio.sleep(1)
    await safe_reply(message, "РџРѕРёСЃРє РїСЂРѕРґРѕР»Р¶Р°РµС‚СЃСЏ... РќР°Р¶РјРёС‚Рµ РѕС‚РјРµРЅСѓ РґР»СЏ РІС‹С…РѕРґР°.", reply_markup=SEARCHING_KB)


async def handle_create_topic(message: Message, text: str, redis: RedisStorage) -> None:
    user_id = message.from_user.id
    if text == BTN_CANCEL:
        await redis.set_state(user_id, UserState.IDLE)
        await redis.set_topic_draft(user_id, None)
        await safe_reply(message, "РћС‚РјРµРЅРµРЅРѕ", reply_markup=MAIN_MENU_KB)
        return
    if not text:
        await safe_reply(message, "Р’РІРµРґРёС‚Рµ РЅРµРїСѓСЃС‚РѕР№ С‚РµРєСЃС‚ С‚РµРјС‹", reply_markup=CREATE_TOPIC_KB)
        return
    await redis.set_topic_draft(user_id, text)
    await redis.set_state(user_id, UserState.CONFIRM_TOPIC)
    await safe_reply(message, f"РўРµРјР°:\n{text}", reply_markup=CONFIRM_TOPIC_KB)


async def handle_confirm_topic(message: Message, text: str, redis: RedisStorage, topics: TopicService) -> None:
    user_id = message.from_user.id
    if text == BTN_CANCEL:
        await redis.set_state(user_id, UserState.IDLE)
        await redis.set_topic_draft(user_id, None)
        await safe_reply(message, "РћС‚РјРµРЅРµРЅРѕ", reply_markup=MAIN_MENU_KB)
        return
    if text != BTN_CONFIRM:
        await safe_reply(message, "РџРѕРґС‚РІРµСЂРґРёС‚Рµ РёР»Рё РѕС‚РјРµРЅРёС‚Рµ", reply_markup=CONFIRM_TOPIC_KB)
        return
    draft = await redis.get_topic_draft(user_id)
    if not draft:
        await redis.set_state(user_id, UserState.IDLE)
        await safe_reply(message, "Р§РµСЂРЅРѕРІРёРє С‚РµРјС‹ РЅРµ РЅР°Р№РґРµРЅ", reply_markup=MAIN_MENU_KB)
        return
    await topics.create_topic(user_id, draft)
    await redis.set_topic_draft(user_id, None)
    await redis.set_state(user_id, UserState.IDLE)
    await safe_reply(message, "РўРµРјР° СЃРѕР·РґР°РЅР°", reply_markup=MAIN_MENU_KB)


async def enter_browse_topics(message: Message, redis: RedisStorage) -> None:
    user_id = message.from_user.id
    topic_ids = await redis.list_topic_ids()
    await redis.set_topic_cursor(user_id, topic_ids, 0)
    await redis.set_state(user_id, UserState.BROWSING_TOPICS)
    await send_current_topic(message, redis)


async def send_current_topic(message: Message, redis: RedisStorage) -> None:
    topic_ids, idx = await redis.get_topic_cursor(message.from_user.id)
    if not topic_ids:
        await redis.set_state(message.from_user.id, UserState.IDLE)
        await safe_reply(message, "РўРµРј РїРѕРєР° РЅРµС‚", reply_markup=MAIN_MENU_KB)
        return
    topic_id = topic_ids[idx % len(topic_ids)]
    topic = await redis.get_topic(topic_id)
    if not topic:
        await safe_reply(message, "РўРµРјР° РёСЃС‚РµРєР»Р°", reply_markup=BROWSE_TOPICS_KB)
        return
    await safe_reply(message, f"РўРµРјР°: {topic['text']}", reply_markup=BROWSE_TOPICS_KB)


async def handle_browsing(
    message: Message,
    text: str,
    redis: RedisStorage,
    matchmaking: MatchmakingService,
    dialogs: DialogService,
) -> None:
    user_id = message.from_user.id
    if text == BTN_BACK:
        await redis.set_state(user_id, UserState.IDLE)
        await safe_reply(message, "Р“Р»Р°РІРЅРѕРµ РјРµРЅСЋ", reply_markup=MAIN_MENU_KB)
        return
    if text == BTN_NEXT_TOPIC:
        topic_ids, idx = await redis.get_topic_cursor(user_id)
        await redis.set_topic_cursor(user_id, topic_ids, idx + 1)
        await send_current_topic(message, redis)
        return
    if text == BTN_REPORT:
        target = await dialogs.report_partner(user_id, "topic_report")
        if target is None:
            await safe_reply(message, "Р–Р°Р»РѕР±Р° СѓС‡С‚РµРЅР°", reply_markup=BROWSE_TOPICS_KB)
            return
        await safe_reply(message, "РџРѕР»СЊР·РѕРІР°С‚РµР»СЊ Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅ", reply_markup=BROWSE_TOPICS_KB)
        return
    if text == BTN_START_DIALOG:
        matched, _dialog_id, partner = await matchmaking.try_match(user_id)
        if matched:
            await safe_reply(message, "Р”РёР°Р»РѕРі РЅР°С‡Р°С‚", reply_markup=DIALOG_KB)
            await safe_send_message(message.bot, partner, "Р”РёР°Р»РѕРі РЅР°С‡Р°С‚", reply_markup=DIALOG_KB)
            return
        await safe_reply(message, "РќРµ СѓРґР°Р»РѕСЃСЊ РЅР°С‡Р°С‚СЊ РґРёР°Р»РѕРі", reply_markup=BROWSE_TOPICS_KB)
        return
    await send_current_topic(message, redis)


async def handle_dialog(message: Message, text: str, redis: RedisStorage, dialogs: DialogService) -> None:
    user_id = message.from_user.id
    if text == BTN_END_DIALOG:
        partner = await dialogs.finish_dialog(user_id, "user_end")
        await safe_reply(message, "Р”РёР°Р»РѕРі Р·Р°РІРµСЂС€С‘РЅ", reply_markup=MAIN_MENU_KB)
        if partner:
            await safe_send_message(message.bot, partner, "РЎРѕР±РµСЃРµРґРЅРёРє Р·Р°РІРµСЂС€РёР» РґРёР°Р»РѕРі", reply_markup=MAIN_MENU_KB)
        return
    if text == BTN_REPORT:
        partner = await dialogs.report_partner(user_id)
        await safe_reply(message, "Р–Р°Р»РѕР±Р° РѕС‚РїСЂР°РІР»РµРЅР°", reply_markup=MAIN_MENU_KB)
        if partner:
            await safe_send_message(message.bot, partner, "Р’С‹ РІСЂРµРјРµРЅРЅРѕ Р·Р°Р±Р»РѕРєРёСЂРѕРІР°РЅС‹", reply_markup=BANNED_KB)
        return

    _dialog_id, partner = await dialogs.get_partner(user_id)
    if partner is None:
        await redis.set_state(user_id, UserState.IDLE)
        await safe_reply(message, "Р”РёР°Р»РѕРі РёСЃС‚РµРє", reply_markup=MAIN_MENU_KB)
        return
    await safe_copy_to(message, partner)